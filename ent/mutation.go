// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/kofalt/example-ent-crdb/ent/predicate"
	"github.com/kofalt/example-ent-crdb/ent/ride"
	"github.com/kofalt/example-ent-crdb/ent/user"
	"github.com/kofalt/example-ent-crdb/ent/userpromocode"
	"github.com/kofalt/example-ent-crdb/ent/vehicle"
	"github.com/kofalt/example-ent-crdb/ent/vehiclelocationhistory"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeRide                   = "Ride"
	TypeUser                   = "User"
	TypeUserPromoCode          = "UserPromoCode"
	TypeVehicle                = "Vehicle"
	TypeVehicleLocationHistory = "VehicleLocationHistory"
)

// RideMutation represents an operation that mutates the Ride nodes in the graph.
type RideMutation struct {
	config
	op                                Op
	typ                               string
	id                                *uuid.UUID
	city                              *string
	vehicle_city                      *string
	start_address                     *string
	end_address                       *string
	start_time                        *time.Time
	end_time                          *time.Time
	revenue                           *float64
	addrevenue                        *float64
	clearedFields                     map[string]struct{}
	user                              *uuid.UUID
	cleareduser                       bool
	vehicle                           *uuid.UUID
	clearedvehicle                    bool
	vehicle_location_histories        map[uuid.UUID]struct{}
	removedvehicle_location_histories map[uuid.UUID]struct{}
	clearedvehicle_location_histories bool
	done                              bool
	oldValue                          func(context.Context) (*Ride, error)
	predicates                        []predicate.Ride
}

var _ ent.Mutation = (*RideMutation)(nil)

// rideOption allows management of the mutation configuration using functional options.
type rideOption func(*RideMutation)

// newRideMutation creates new mutation for the Ride entity.
func newRideMutation(c config, op Op, opts ...rideOption) *RideMutation {
	m := &RideMutation{
		config:        c,
		op:            op,
		typ:           TypeRide,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRideID sets the ID field of the mutation.
func withRideID(id uuid.UUID) rideOption {
	return func(m *RideMutation) {
		var (
			err   error
			once  sync.Once
			value *Ride
		)
		m.oldValue = func(ctx context.Context) (*Ride, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ride.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRide sets the old Ride of the mutation.
func withRide(node *Ride) rideOption {
	return func(m *RideMutation) {
		m.oldValue = func(context.Context) (*Ride, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ride entities.
func (m *RideMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RideMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RideMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ride.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *RideMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *RideMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *RideMutation) ResetCity() {
	m.city = nil
}

// SetVehicleCity sets the "vehicle_city" field.
func (m *RideMutation) SetVehicleCity(s string) {
	m.vehicle_city = &s
}

// VehicleCity returns the value of the "vehicle_city" field in the mutation.
func (m *RideMutation) VehicleCity() (r string, exists bool) {
	v := m.vehicle_city
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleCity returns the old "vehicle_city" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldVehicleCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleCity: %w", err)
	}
	return oldValue.VehicleCity, nil
}

// ClearVehicleCity clears the value of the "vehicle_city" field.
func (m *RideMutation) ClearVehicleCity() {
	m.vehicle_city = nil
	m.clearedFields[ride.FieldVehicleCity] = struct{}{}
}

// VehicleCityCleared returns if the "vehicle_city" field was cleared in this mutation.
func (m *RideMutation) VehicleCityCleared() bool {
	_, ok := m.clearedFields[ride.FieldVehicleCity]
	return ok
}

// ResetVehicleCity resets all changes to the "vehicle_city" field.
func (m *RideMutation) ResetVehicleCity() {
	m.vehicle_city = nil
	delete(m.clearedFields, ride.FieldVehicleCity)
}

// SetRiderID sets the "rider_id" field.
func (m *RideMutation) SetRiderID(u uuid.UUID) {
	m.user = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *RideMutation) RiderID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldRiderID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *RideMutation) ClearRiderID() {
	m.user = nil
	m.clearedFields[ride.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *RideMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[ride.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *RideMutation) ResetRiderID() {
	m.user = nil
	delete(m.clearedFields, ride.FieldRiderID)
}

// SetVehicleID sets the "vehicle_id" field.
func (m *RideMutation) SetVehicleID(u uuid.UUID) {
	m.vehicle = &u
}

// VehicleID returns the value of the "vehicle_id" field in the mutation.
func (m *RideMutation) VehicleID() (r uuid.UUID, exists bool) {
	v := m.vehicle
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleID returns the old "vehicle_id" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldVehicleID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleID: %w", err)
	}
	return oldValue.VehicleID, nil
}

// ClearVehicleID clears the value of the "vehicle_id" field.
func (m *RideMutation) ClearVehicleID() {
	m.vehicle = nil
	m.clearedFields[ride.FieldVehicleID] = struct{}{}
}

// VehicleIDCleared returns if the "vehicle_id" field was cleared in this mutation.
func (m *RideMutation) VehicleIDCleared() bool {
	_, ok := m.clearedFields[ride.FieldVehicleID]
	return ok
}

// ResetVehicleID resets all changes to the "vehicle_id" field.
func (m *RideMutation) ResetVehicleID() {
	m.vehicle = nil
	delete(m.clearedFields, ride.FieldVehicleID)
}

// SetStartAddress sets the "start_address" field.
func (m *RideMutation) SetStartAddress(s string) {
	m.start_address = &s
}

// StartAddress returns the value of the "start_address" field in the mutation.
func (m *RideMutation) StartAddress() (r string, exists bool) {
	v := m.start_address
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAddress returns the old "start_address" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldStartAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAddress: %w", err)
	}
	return oldValue.StartAddress, nil
}

// ClearStartAddress clears the value of the "start_address" field.
func (m *RideMutation) ClearStartAddress() {
	m.start_address = nil
	m.clearedFields[ride.FieldStartAddress] = struct{}{}
}

// StartAddressCleared returns if the "start_address" field was cleared in this mutation.
func (m *RideMutation) StartAddressCleared() bool {
	_, ok := m.clearedFields[ride.FieldStartAddress]
	return ok
}

// ResetStartAddress resets all changes to the "start_address" field.
func (m *RideMutation) ResetStartAddress() {
	m.start_address = nil
	delete(m.clearedFields, ride.FieldStartAddress)
}

// SetEndAddress sets the "end_address" field.
func (m *RideMutation) SetEndAddress(s string) {
	m.end_address = &s
}

// EndAddress returns the value of the "end_address" field in the mutation.
func (m *RideMutation) EndAddress() (r string, exists bool) {
	v := m.end_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAddress returns the old "end_address" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldEndAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAddress: %w", err)
	}
	return oldValue.EndAddress, nil
}

// ClearEndAddress clears the value of the "end_address" field.
func (m *RideMutation) ClearEndAddress() {
	m.end_address = nil
	m.clearedFields[ride.FieldEndAddress] = struct{}{}
}

// EndAddressCleared returns if the "end_address" field was cleared in this mutation.
func (m *RideMutation) EndAddressCleared() bool {
	_, ok := m.clearedFields[ride.FieldEndAddress]
	return ok
}

// ResetEndAddress resets all changes to the "end_address" field.
func (m *RideMutation) ResetEndAddress() {
	m.end_address = nil
	delete(m.clearedFields, ride.FieldEndAddress)
}

// SetStartTime sets the "start_time" field.
func (m *RideMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *RideMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "start_time" field.
func (m *RideMutation) ClearStartTime() {
	m.start_time = nil
	m.clearedFields[ride.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "start_time" field was cleared in this mutation.
func (m *RideMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[ride.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *RideMutation) ResetStartTime() {
	m.start_time = nil
	delete(m.clearedFields, ride.FieldStartTime)
}

// SetEndTime sets the "end_time" field.
func (m *RideMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *RideMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "end_time" field.
func (m *RideMutation) ClearEndTime() {
	m.end_time = nil
	m.clearedFields[ride.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "end_time" field was cleared in this mutation.
func (m *RideMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[ride.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *RideMutation) ResetEndTime() {
	m.end_time = nil
	delete(m.clearedFields, ride.FieldEndTime)
}

// SetRevenue sets the "revenue" field.
func (m *RideMutation) SetRevenue(f float64) {
	m.revenue = &f
	m.addrevenue = nil
}

// Revenue returns the value of the "revenue" field in the mutation.
func (m *RideMutation) Revenue() (r float64, exists bool) {
	v := m.revenue
	if v == nil {
		return
	}
	return *v, true
}

// OldRevenue returns the old "revenue" field's value of the Ride entity.
// If the Ride object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RideMutation) OldRevenue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevenue: %w", err)
	}
	return oldValue.Revenue, nil
}

// AddRevenue adds f to the "revenue" field.
func (m *RideMutation) AddRevenue(f float64) {
	if m.addrevenue != nil {
		*m.addrevenue += f
	} else {
		m.addrevenue = &f
	}
}

// AddedRevenue returns the value that was added to the "revenue" field in this mutation.
func (m *RideMutation) AddedRevenue() (r float64, exists bool) {
	v := m.addrevenue
	if v == nil {
		return
	}
	return *v, true
}

// ClearRevenue clears the value of the "revenue" field.
func (m *RideMutation) ClearRevenue() {
	m.revenue = nil
	m.addrevenue = nil
	m.clearedFields[ride.FieldRevenue] = struct{}{}
}

// RevenueCleared returns if the "revenue" field was cleared in this mutation.
func (m *RideMutation) RevenueCleared() bool {
	_, ok := m.clearedFields[ride.FieldRevenue]
	return ok
}

// ResetRevenue resets all changes to the "revenue" field.
func (m *RideMutation) ResetRevenue() {
	m.revenue = nil
	m.addrevenue = nil
	delete(m.clearedFields, ride.FieldRevenue)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RideMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RideMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RideMutation) UserCleared() bool {
	return m.RiderIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RideMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RideMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RideMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearVehicle clears the "vehicle" edge to the Vehicle entity.
func (m *RideMutation) ClearVehicle() {
	m.clearedvehicle = true
}

// VehicleCleared reports if the "vehicle" edge to the Vehicle entity was cleared.
func (m *RideMutation) VehicleCleared() bool {
	return m.VehicleIDCleared() || m.clearedvehicle
}

// VehicleIDs returns the "vehicle" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VehicleID instead. It exists only for internal usage by the builders.
func (m *RideMutation) VehicleIDs() (ids []uuid.UUID) {
	if id := m.vehicle; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVehicle resets all changes to the "vehicle" edge.
func (m *RideMutation) ResetVehicle() {
	m.vehicle = nil
	m.clearedvehicle = false
}

// AddVehicleLocationHistoryIDs adds the "vehicle_location_histories" edge to the VehicleLocationHistory entity by ids.
func (m *RideMutation) AddVehicleLocationHistoryIDs(ids ...uuid.UUID) {
	if m.vehicle_location_histories == nil {
		m.vehicle_location_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vehicle_location_histories[ids[i]] = struct{}{}
	}
}

// ClearVehicleLocationHistories clears the "vehicle_location_histories" edge to the VehicleLocationHistory entity.
func (m *RideMutation) ClearVehicleLocationHistories() {
	m.clearedvehicle_location_histories = true
}

// VehicleLocationHistoriesCleared reports if the "vehicle_location_histories" edge to the VehicleLocationHistory entity was cleared.
func (m *RideMutation) VehicleLocationHistoriesCleared() bool {
	return m.clearedvehicle_location_histories
}

// RemoveVehicleLocationHistoryIDs removes the "vehicle_location_histories" edge to the VehicleLocationHistory entity by IDs.
func (m *RideMutation) RemoveVehicleLocationHistoryIDs(ids ...uuid.UUID) {
	if m.removedvehicle_location_histories == nil {
		m.removedvehicle_location_histories = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vehicle_location_histories, ids[i])
		m.removedvehicle_location_histories[ids[i]] = struct{}{}
	}
}

// RemovedVehicleLocationHistories returns the removed IDs of the "vehicle_location_histories" edge to the VehicleLocationHistory entity.
func (m *RideMutation) RemovedVehicleLocationHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.removedvehicle_location_histories {
		ids = append(ids, id)
	}
	return
}

// VehicleLocationHistoriesIDs returns the "vehicle_location_histories" edge IDs in the mutation.
func (m *RideMutation) VehicleLocationHistoriesIDs() (ids []uuid.UUID) {
	for id := range m.vehicle_location_histories {
		ids = append(ids, id)
	}
	return
}

// ResetVehicleLocationHistories resets all changes to the "vehicle_location_histories" edge.
func (m *RideMutation) ResetVehicleLocationHistories() {
	m.vehicle_location_histories = nil
	m.clearedvehicle_location_histories = false
	m.removedvehicle_location_histories = nil
}

// Where appends a list predicates to the RideMutation builder.
func (m *RideMutation) Where(ps ...predicate.Ride) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ride, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ride).
func (m *RideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RideMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.city != nil {
		fields = append(fields, ride.FieldCity)
	}
	if m.vehicle_city != nil {
		fields = append(fields, ride.FieldVehicleCity)
	}
	if m.user != nil {
		fields = append(fields, ride.FieldRiderID)
	}
	if m.vehicle != nil {
		fields = append(fields, ride.FieldVehicleID)
	}
	if m.start_address != nil {
		fields = append(fields, ride.FieldStartAddress)
	}
	if m.end_address != nil {
		fields = append(fields, ride.FieldEndAddress)
	}
	if m.start_time != nil {
		fields = append(fields, ride.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, ride.FieldEndTime)
	}
	if m.revenue != nil {
		fields = append(fields, ride.FieldRevenue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ride.FieldCity:
		return m.City()
	case ride.FieldVehicleCity:
		return m.VehicleCity()
	case ride.FieldRiderID:
		return m.RiderID()
	case ride.FieldVehicleID:
		return m.VehicleID()
	case ride.FieldStartAddress:
		return m.StartAddress()
	case ride.FieldEndAddress:
		return m.EndAddress()
	case ride.FieldStartTime:
		return m.StartTime()
	case ride.FieldEndTime:
		return m.EndTime()
	case ride.FieldRevenue:
		return m.Revenue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ride.FieldCity:
		return m.OldCity(ctx)
	case ride.FieldVehicleCity:
		return m.OldVehicleCity(ctx)
	case ride.FieldRiderID:
		return m.OldRiderID(ctx)
	case ride.FieldVehicleID:
		return m.OldVehicleID(ctx)
	case ride.FieldStartAddress:
		return m.OldStartAddress(ctx)
	case ride.FieldEndAddress:
		return m.OldEndAddress(ctx)
	case ride.FieldStartTime:
		return m.OldStartTime(ctx)
	case ride.FieldEndTime:
		return m.OldEndTime(ctx)
	case ride.FieldRevenue:
		return m.OldRevenue(ctx)
	}
	return nil, fmt.Errorf("unknown Ride field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ride.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case ride.FieldVehicleCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleCity(v)
		return nil
	case ride.FieldRiderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case ride.FieldVehicleID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleID(v)
		return nil
	case ride.FieldStartAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAddress(v)
		return nil
	case ride.FieldEndAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAddress(v)
		return nil
	case ride.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case ride.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case ride.FieldRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevenue(v)
		return nil
	}
	return fmt.Errorf("unknown Ride field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RideMutation) AddedFields() []string {
	var fields []string
	if m.addrevenue != nil {
		fields = append(fields, ride.FieldRevenue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ride.FieldRevenue:
		return m.AddedRevenue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ride.FieldRevenue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevenue(v)
		return nil
	}
	return fmt.Errorf("unknown Ride numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ride.FieldVehicleCity) {
		fields = append(fields, ride.FieldVehicleCity)
	}
	if m.FieldCleared(ride.FieldRiderID) {
		fields = append(fields, ride.FieldRiderID)
	}
	if m.FieldCleared(ride.FieldVehicleID) {
		fields = append(fields, ride.FieldVehicleID)
	}
	if m.FieldCleared(ride.FieldStartAddress) {
		fields = append(fields, ride.FieldStartAddress)
	}
	if m.FieldCleared(ride.FieldEndAddress) {
		fields = append(fields, ride.FieldEndAddress)
	}
	if m.FieldCleared(ride.FieldStartTime) {
		fields = append(fields, ride.FieldStartTime)
	}
	if m.FieldCleared(ride.FieldEndTime) {
		fields = append(fields, ride.FieldEndTime)
	}
	if m.FieldCleared(ride.FieldRevenue) {
		fields = append(fields, ride.FieldRevenue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RideMutation) ClearField(name string) error {
	switch name {
	case ride.FieldVehicleCity:
		m.ClearVehicleCity()
		return nil
	case ride.FieldRiderID:
		m.ClearRiderID()
		return nil
	case ride.FieldVehicleID:
		m.ClearVehicleID()
		return nil
	case ride.FieldStartAddress:
		m.ClearStartAddress()
		return nil
	case ride.FieldEndAddress:
		m.ClearEndAddress()
		return nil
	case ride.FieldStartTime:
		m.ClearStartTime()
		return nil
	case ride.FieldEndTime:
		m.ClearEndTime()
		return nil
	case ride.FieldRevenue:
		m.ClearRevenue()
		return nil
	}
	return fmt.Errorf("unknown Ride nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RideMutation) ResetField(name string) error {
	switch name {
	case ride.FieldCity:
		m.ResetCity()
		return nil
	case ride.FieldVehicleCity:
		m.ResetVehicleCity()
		return nil
	case ride.FieldRiderID:
		m.ResetRiderID()
		return nil
	case ride.FieldVehicleID:
		m.ResetVehicleID()
		return nil
	case ride.FieldStartAddress:
		m.ResetStartAddress()
		return nil
	case ride.FieldEndAddress:
		m.ResetEndAddress()
		return nil
	case ride.FieldStartTime:
		m.ResetStartTime()
		return nil
	case ride.FieldEndTime:
		m.ResetEndTime()
		return nil
	case ride.FieldRevenue:
		m.ResetRevenue()
		return nil
	}
	return fmt.Errorf("unknown Ride field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RideMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, ride.EdgeUser)
	}
	if m.vehicle != nil {
		edges = append(edges, ride.EdgeVehicle)
	}
	if m.vehicle_location_histories != nil {
		edges = append(edges, ride.EdgeVehicleLocationHistories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RideMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ride.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case ride.EdgeVehicle:
		if id := m.vehicle; id != nil {
			return []ent.Value{*id}
		}
	case ride.EdgeVehicleLocationHistories:
		ids := make([]ent.Value, 0, len(m.vehicle_location_histories))
		for id := range m.vehicle_location_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvehicle_location_histories != nil {
		edges = append(edges, ride.EdgeVehicleLocationHistories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RideMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ride.EdgeVehicleLocationHistories:
		ids := make([]ent.Value, 0, len(m.removedvehicle_location_histories))
		for id := range m.removedvehicle_location_histories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, ride.EdgeUser)
	}
	if m.clearedvehicle {
		edges = append(edges, ride.EdgeVehicle)
	}
	if m.clearedvehicle_location_histories {
		edges = append(edges, ride.EdgeVehicleLocationHistories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RideMutation) EdgeCleared(name string) bool {
	switch name {
	case ride.EdgeUser:
		return m.cleareduser
	case ride.EdgeVehicle:
		return m.clearedvehicle
	case ride.EdgeVehicleLocationHistories:
		return m.clearedvehicle_location_histories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RideMutation) ClearEdge(name string) error {
	switch name {
	case ride.EdgeUser:
		m.ClearUser()
		return nil
	case ride.EdgeVehicle:
		m.ClearVehicle()
		return nil
	}
	return fmt.Errorf("unknown Ride unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RideMutation) ResetEdge(name string) error {
	switch name {
	case ride.EdgeUser:
		m.ResetUser()
		return nil
	case ride.EdgeVehicle:
		m.ResetVehicle()
		return nil
	case ride.EdgeVehicleLocationHistories:
		m.ResetVehicleLocationHistories()
		return nil
	}
	return fmt.Errorf("unknown Ride edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	city                    *string
	name                    *string
	address                 *string
	credit_card             *string
	clearedFields           map[string]struct{}
	vehicles                map[uuid.UUID]struct{}
	removedvehicles         map[uuid.UUID]struct{}
	clearedvehicles         bool
	rides                   map[uuid.UUID]struct{}
	removedrides            map[uuid.UUID]struct{}
	clearedrides            bool
	user_promo_codes        map[uuid.UUID]struct{}
	removeduser_promo_codes map[uuid.UUID]struct{}
	cleareduser_promo_codes bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *UserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserMutation) ResetCity() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *UserMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[user.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *UserMutation) AddressCleared() bool {
	_, ok := m.clearedFields[user.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, user.FieldAddress)
}

// SetCreditCard sets the "credit_card" field.
func (m *UserMutation) SetCreditCard(s string) {
	m.credit_card = &s
}

// CreditCard returns the value of the "credit_card" field in the mutation.
func (m *UserMutation) CreditCard() (r string, exists bool) {
	v := m.credit_card
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditCard returns the old "credit_card" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreditCard(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditCard: %w", err)
	}
	return oldValue.CreditCard, nil
}

// ClearCreditCard clears the value of the "credit_card" field.
func (m *UserMutation) ClearCreditCard() {
	m.credit_card = nil
	m.clearedFields[user.FieldCreditCard] = struct{}{}
}

// CreditCardCleared returns if the "credit_card" field was cleared in this mutation.
func (m *UserMutation) CreditCardCleared() bool {
	_, ok := m.clearedFields[user.FieldCreditCard]
	return ok
}

// ResetCreditCard resets all changes to the "credit_card" field.
func (m *UserMutation) ResetCreditCard() {
	m.credit_card = nil
	delete(m.clearedFields, user.FieldCreditCard)
}

// AddVehicleIDs adds the "vehicles" edge to the Vehicle entity by ids.
func (m *UserMutation) AddVehicleIDs(ids ...uuid.UUID) {
	if m.vehicles == nil {
		m.vehicles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vehicles[ids[i]] = struct{}{}
	}
}

// ClearVehicles clears the "vehicles" edge to the Vehicle entity.
func (m *UserMutation) ClearVehicles() {
	m.clearedvehicles = true
}

// VehiclesCleared reports if the "vehicles" edge to the Vehicle entity was cleared.
func (m *UserMutation) VehiclesCleared() bool {
	return m.clearedvehicles
}

// RemoveVehicleIDs removes the "vehicles" edge to the Vehicle entity by IDs.
func (m *UserMutation) RemoveVehicleIDs(ids ...uuid.UUID) {
	if m.removedvehicles == nil {
		m.removedvehicles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vehicles, ids[i])
		m.removedvehicles[ids[i]] = struct{}{}
	}
}

// RemovedVehicles returns the removed IDs of the "vehicles" edge to the Vehicle entity.
func (m *UserMutation) RemovedVehiclesIDs() (ids []uuid.UUID) {
	for id := range m.removedvehicles {
		ids = append(ids, id)
	}
	return
}

// VehiclesIDs returns the "vehicles" edge IDs in the mutation.
func (m *UserMutation) VehiclesIDs() (ids []uuid.UUID) {
	for id := range m.vehicles {
		ids = append(ids, id)
	}
	return
}

// ResetVehicles resets all changes to the "vehicles" edge.
func (m *UserMutation) ResetVehicles() {
	m.vehicles = nil
	m.clearedvehicles = false
	m.removedvehicles = nil
}

// AddRideIDs adds the "rides" edge to the Ride entity by ids.
func (m *UserMutation) AddRideIDs(ids ...uuid.UUID) {
	if m.rides == nil {
		m.rides = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.rides[ids[i]] = struct{}{}
	}
}

// ClearRides clears the "rides" edge to the Ride entity.
func (m *UserMutation) ClearRides() {
	m.clearedrides = true
}

// RidesCleared reports if the "rides" edge to the Ride entity was cleared.
func (m *UserMutation) RidesCleared() bool {
	return m.clearedrides
}

// RemoveRideIDs removes the "rides" edge to the Ride entity by IDs.
func (m *UserMutation) RemoveRideIDs(ids ...uuid.UUID) {
	if m.removedrides == nil {
		m.removedrides = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.rides, ids[i])
		m.removedrides[ids[i]] = struct{}{}
	}
}

// RemovedRides returns the removed IDs of the "rides" edge to the Ride entity.
func (m *UserMutation) RemovedRidesIDs() (ids []uuid.UUID) {
	for id := range m.removedrides {
		ids = append(ids, id)
	}
	return
}

// RidesIDs returns the "rides" edge IDs in the mutation.
func (m *UserMutation) RidesIDs() (ids []uuid.UUID) {
	for id := range m.rides {
		ids = append(ids, id)
	}
	return
}

// ResetRides resets all changes to the "rides" edge.
func (m *UserMutation) ResetRides() {
	m.rides = nil
	m.clearedrides = false
	m.removedrides = nil
}

// AddUserPromoCodeIDs adds the "user_promo_codes" edge to the UserPromoCode entity by ids.
func (m *UserMutation) AddUserPromoCodeIDs(ids ...uuid.UUID) {
	if m.user_promo_codes == nil {
		m.user_promo_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.user_promo_codes[ids[i]] = struct{}{}
	}
}

// ClearUserPromoCodes clears the "user_promo_codes" edge to the UserPromoCode entity.
func (m *UserMutation) ClearUserPromoCodes() {
	m.cleareduser_promo_codes = true
}

// UserPromoCodesCleared reports if the "user_promo_codes" edge to the UserPromoCode entity was cleared.
func (m *UserMutation) UserPromoCodesCleared() bool {
	return m.cleareduser_promo_codes
}

// RemoveUserPromoCodeIDs removes the "user_promo_codes" edge to the UserPromoCode entity by IDs.
func (m *UserMutation) RemoveUserPromoCodeIDs(ids ...uuid.UUID) {
	if m.removeduser_promo_codes == nil {
		m.removeduser_promo_codes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.user_promo_codes, ids[i])
		m.removeduser_promo_codes[ids[i]] = struct{}{}
	}
}

// RemovedUserPromoCodes returns the removed IDs of the "user_promo_codes" edge to the UserPromoCode entity.
func (m *UserMutation) RemovedUserPromoCodesIDs() (ids []uuid.UUID) {
	for id := range m.removeduser_promo_codes {
		ids = append(ids, id)
	}
	return
}

// UserPromoCodesIDs returns the "user_promo_codes" edge IDs in the mutation.
func (m *UserMutation) UserPromoCodesIDs() (ids []uuid.UUID) {
	for id := range m.user_promo_codes {
		ids = append(ids, id)
	}
	return
}

// ResetUserPromoCodes resets all changes to the "user_promo_codes" edge.
func (m *UserMutation) ResetUserPromoCodes() {
	m.user_promo_codes = nil
	m.cleareduser_promo_codes = false
	m.removeduser_promo_codes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.city != nil {
		fields = append(fields, user.FieldCity)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.credit_card != nil {
		fields = append(fields, user.FieldCreditCard)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCity:
		return m.City()
	case user.FieldName:
		return m.Name()
	case user.FieldAddress:
		return m.Address()
	case user.FieldCreditCard:
		return m.CreditCard()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCity:
		return m.OldCity(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldCreditCard:
		return m.OldCreditCard(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldCreditCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditCard(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldAddress) {
		fields = append(fields, user.FieldAddress)
	}
	if m.FieldCleared(user.FieldCreditCard) {
		fields = append(fields, user.FieldCreditCard)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldAddress:
		m.ClearAddress()
		return nil
	case user.FieldCreditCard:
		m.ClearCreditCard()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCity:
		m.ResetCity()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldCreditCard:
		m.ResetCreditCard()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.vehicles != nil {
		edges = append(edges, user.EdgeVehicles)
	}
	if m.rides != nil {
		edges = append(edges, user.EdgeRides)
	}
	if m.user_promo_codes != nil {
		edges = append(edges, user.EdgeUserPromoCodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.vehicles))
		for id := range m.vehicles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRides:
		ids := make([]ent.Value, 0, len(m.rides))
		for id := range m.rides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPromoCodes:
		ids := make([]ent.Value, 0, len(m.user_promo_codes))
		for id := range m.user_promo_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvehicles != nil {
		edges = append(edges, user.EdgeVehicles)
	}
	if m.removedrides != nil {
		edges = append(edges, user.EdgeRides)
	}
	if m.removeduser_promo_codes != nil {
		edges = append(edges, user.EdgeUserPromoCodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVehicles:
		ids := make([]ent.Value, 0, len(m.removedvehicles))
		for id := range m.removedvehicles {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRides:
		ids := make([]ent.Value, 0, len(m.removedrides))
		for id := range m.removedrides {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserPromoCodes:
		ids := make([]ent.Value, 0, len(m.removeduser_promo_codes))
		for id := range m.removeduser_promo_codes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedvehicles {
		edges = append(edges, user.EdgeVehicles)
	}
	if m.clearedrides {
		edges = append(edges, user.EdgeRides)
	}
	if m.cleareduser_promo_codes {
		edges = append(edges, user.EdgeUserPromoCodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVehicles:
		return m.clearedvehicles
	case user.EdgeRides:
		return m.clearedrides
	case user.EdgeUserPromoCodes:
		return m.cleareduser_promo_codes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVehicles:
		m.ResetVehicles()
		return nil
	case user.EdgeRides:
		m.ResetRides()
		return nil
	case user.EdgeUserPromoCodes:
		m.ResetUserPromoCodes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserPromoCodeMutation represents an operation that mutates the UserPromoCode nodes in the graph.
type UserPromoCodeMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	city           *string
	code           *string
	timestamp      *time.Time
	usage_count    *int
	addusage_count *int
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserPromoCode, error)
	predicates     []predicate.UserPromoCode
}

var _ ent.Mutation = (*UserPromoCodeMutation)(nil)

// userpromocodeOption allows management of the mutation configuration using functional options.
type userpromocodeOption func(*UserPromoCodeMutation)

// newUserPromoCodeMutation creates new mutation for the UserPromoCode entity.
func newUserPromoCodeMutation(c config, op Op, opts ...userpromocodeOption) *UserPromoCodeMutation {
	m := &UserPromoCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPromoCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPromoCodeID sets the ID field of the mutation.
func withUserPromoCodeID(id uuid.UUID) userpromocodeOption {
	return func(m *UserPromoCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPromoCode
		)
		m.oldValue = func(ctx context.Context) (*UserPromoCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPromoCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPromoCode sets the old UserPromoCode of the mutation.
func withUserPromoCode(node *UserPromoCode) userpromocodeOption {
	return func(m *UserPromoCodeMutation) {
		m.oldValue = func(context.Context) (*UserPromoCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPromoCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPromoCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPromoCode entities.
func (m *UserPromoCodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPromoCodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserPromoCodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserPromoCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *UserPromoCodeMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserPromoCodeMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the UserPromoCode entity.
// If the UserPromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPromoCodeMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserPromoCodeMutation) ResetCity() {
	m.city = nil
}

// SetUserID sets the "user_id" field.
func (m *UserPromoCodeMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPromoCodeMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPromoCode entity.
// If the UserPromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPromoCodeMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPromoCodeMutation) ResetUserID() {
	m.user = nil
}

// SetCode sets the "code" field.
func (m *UserPromoCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *UserPromoCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the UserPromoCode entity.
// If the UserPromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPromoCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *UserPromoCodeMutation) ResetCode() {
	m.code = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *UserPromoCodeMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *UserPromoCodeMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the UserPromoCode entity.
// If the UserPromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPromoCodeMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ClearTimestamp clears the value of the "timestamp" field.
func (m *UserPromoCodeMutation) ClearTimestamp() {
	m.timestamp = nil
	m.clearedFields[userpromocode.FieldTimestamp] = struct{}{}
}

// TimestampCleared returns if the "timestamp" field was cleared in this mutation.
func (m *UserPromoCodeMutation) TimestampCleared() bool {
	_, ok := m.clearedFields[userpromocode.FieldTimestamp]
	return ok
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *UserPromoCodeMutation) ResetTimestamp() {
	m.timestamp = nil
	delete(m.clearedFields, userpromocode.FieldTimestamp)
}

// SetUsageCount sets the "usage_count" field.
func (m *UserPromoCodeMutation) SetUsageCount(i int) {
	m.usage_count = &i
	m.addusage_count = nil
}

// UsageCount returns the value of the "usage_count" field in the mutation.
func (m *UserPromoCodeMutation) UsageCount() (r int, exists bool) {
	v := m.usage_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsageCount returns the old "usage_count" field's value of the UserPromoCode entity.
// If the UserPromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPromoCodeMutation) OldUsageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsageCount: %w", err)
	}
	return oldValue.UsageCount, nil
}

// AddUsageCount adds i to the "usage_count" field.
func (m *UserPromoCodeMutation) AddUsageCount(i int) {
	if m.addusage_count != nil {
		*m.addusage_count += i
	} else {
		m.addusage_count = &i
	}
}

// AddedUsageCount returns the value that was added to the "usage_count" field in this mutation.
func (m *UserPromoCodeMutation) AddedUsageCount() (r int, exists bool) {
	v := m.addusage_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearUsageCount clears the value of the "usage_count" field.
func (m *UserPromoCodeMutation) ClearUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
	m.clearedFields[userpromocode.FieldUsageCount] = struct{}{}
}

// UsageCountCleared returns if the "usage_count" field was cleared in this mutation.
func (m *UserPromoCodeMutation) UsageCountCleared() bool {
	_, ok := m.clearedFields[userpromocode.FieldUsageCount]
	return ok
}

// ResetUsageCount resets all changes to the "usage_count" field.
func (m *UserPromoCodeMutation) ResetUsageCount() {
	m.usage_count = nil
	m.addusage_count = nil
	delete(m.clearedFields, userpromocode.FieldUsageCount)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserPromoCodeMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserPromoCodeMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserPromoCodeMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserPromoCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserPromoCodeMutation builder.
func (m *UserPromoCodeMutation) Where(ps ...predicate.UserPromoCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserPromoCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserPromoCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserPromoCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserPromoCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserPromoCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserPromoCode).
func (m *UserPromoCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPromoCodeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.city != nil {
		fields = append(fields, userpromocode.FieldCity)
	}
	if m.user != nil {
		fields = append(fields, userpromocode.FieldUserID)
	}
	if m.code != nil {
		fields = append(fields, userpromocode.FieldCode)
	}
	if m.timestamp != nil {
		fields = append(fields, userpromocode.FieldTimestamp)
	}
	if m.usage_count != nil {
		fields = append(fields, userpromocode.FieldUsageCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPromoCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpromocode.FieldCity:
		return m.City()
	case userpromocode.FieldUserID:
		return m.UserID()
	case userpromocode.FieldCode:
		return m.Code()
	case userpromocode.FieldTimestamp:
		return m.Timestamp()
	case userpromocode.FieldUsageCount:
		return m.UsageCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPromoCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpromocode.FieldCity:
		return m.OldCity(ctx)
	case userpromocode.FieldUserID:
		return m.OldUserID(ctx)
	case userpromocode.FieldCode:
		return m.OldCode(ctx)
	case userpromocode.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case userpromocode.FieldUsageCount:
		return m.OldUsageCount(ctx)
	}
	return nil, fmt.Errorf("unknown UserPromoCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPromoCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpromocode.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case userpromocode.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpromocode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case userpromocode.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case userpromocode.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPromoCodeMutation) AddedFields() []string {
	var fields []string
	if m.addusage_count != nil {
		fields = append(fields, userpromocode.FieldUsageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPromoCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpromocode.FieldUsageCount:
		return m.AddedUsageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPromoCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpromocode.FieldUsageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsageCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPromoCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpromocode.FieldTimestamp) {
		fields = append(fields, userpromocode.FieldTimestamp)
	}
	if m.FieldCleared(userpromocode.FieldUsageCount) {
		fields = append(fields, userpromocode.FieldUsageCount)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPromoCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPromoCodeMutation) ClearField(name string) error {
	switch name {
	case userpromocode.FieldTimestamp:
		m.ClearTimestamp()
		return nil
	case userpromocode.FieldUsageCount:
		m.ClearUsageCount()
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPromoCodeMutation) ResetField(name string) error {
	switch name {
	case userpromocode.FieldCity:
		m.ResetCity()
		return nil
	case userpromocode.FieldUserID:
		m.ResetUserID()
		return nil
	case userpromocode.FieldCode:
		m.ResetCode()
		return nil
	case userpromocode.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case userpromocode.FieldUsageCount:
		m.ResetUsageCount()
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPromoCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userpromocode.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPromoCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userpromocode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPromoCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPromoCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPromoCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userpromocode.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPromoCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case userpromocode.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPromoCodeMutation) ClearEdge(name string) error {
	switch name {
	case userpromocode.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPromoCodeMutation) ResetEdge(name string) error {
	switch name {
	case userpromocode.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserPromoCode edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	city             *string
	_type            *string
	creation_time    *time.Time
	status           *string
	current_location *string
	ext              **map[string]interface{}
	clearedFields    map[string]struct{}
	user             *uuid.UUID
	cleareduser      bool
	rides            map[uuid.UUID]struct{}
	removedrides     map[uuid.UUID]struct{}
	clearedrides     bool
	done             bool
	oldValue         func(context.Context) (*Vehicle, error)
	predicates       []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id uuid.UUID) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vehicle entities.
func (m *VehicleMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *VehicleMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VehicleMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *VehicleMutation) ResetCity() {
	m.city = nil
}

// SetType sets the "type" field.
func (m *VehicleMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *VehicleMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *VehicleMutation) ClearType() {
	m._type = nil
	m.clearedFields[vehicle.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *VehicleMutation) TypeCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *VehicleMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, vehicle.FieldType)
}

// SetOwnerID sets the "owner_id" field.
func (m *VehicleMutation) SetOwnerID(u uuid.UUID) {
	m.user = &u
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *VehicleMutation) OwnerID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldOwnerID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *VehicleMutation) ClearOwnerID() {
	m.user = nil
	m.clearedFields[vehicle.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *VehicleMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *VehicleMutation) ResetOwnerID() {
	m.user = nil
	delete(m.clearedFields, vehicle.FieldOwnerID)
}

// SetCreationTime sets the "creation_time" field.
func (m *VehicleMutation) SetCreationTime(t time.Time) {
	m.creation_time = &t
}

// CreationTime returns the value of the "creation_time" field in the mutation.
func (m *VehicleMutation) CreationTime() (r time.Time, exists bool) {
	v := m.creation_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreationTime returns the old "creation_time" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreationTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreationTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreationTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreationTime: %w", err)
	}
	return oldValue.CreationTime, nil
}

// ClearCreationTime clears the value of the "creation_time" field.
func (m *VehicleMutation) ClearCreationTime() {
	m.creation_time = nil
	m.clearedFields[vehicle.FieldCreationTime] = struct{}{}
}

// CreationTimeCleared returns if the "creation_time" field was cleared in this mutation.
func (m *VehicleMutation) CreationTimeCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCreationTime]
	return ok
}

// ResetCreationTime resets all changes to the "creation_time" field.
func (m *VehicleMutation) ResetCreationTime() {
	m.creation_time = nil
	delete(m.clearedFields, vehicle.FieldCreationTime)
}

// SetStatus sets the "status" field.
func (m *VehicleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *VehicleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *VehicleMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[vehicle.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *VehicleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *VehicleMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, vehicle.FieldStatus)
}

// SetCurrentLocation sets the "current_location" field.
func (m *VehicleMutation) SetCurrentLocation(s string) {
	m.current_location = &s
}

// CurrentLocation returns the value of the "current_location" field in the mutation.
func (m *VehicleMutation) CurrentLocation() (r string, exists bool) {
	v := m.current_location
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentLocation returns the old "current_location" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCurrentLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentLocation: %w", err)
	}
	return oldValue.CurrentLocation, nil
}

// ClearCurrentLocation clears the value of the "current_location" field.
func (m *VehicleMutation) ClearCurrentLocation() {
	m.current_location = nil
	m.clearedFields[vehicle.FieldCurrentLocation] = struct{}{}
}

// CurrentLocationCleared returns if the "current_location" field was cleared in this mutation.
func (m *VehicleMutation) CurrentLocationCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldCurrentLocation]
	return ok
}

// ResetCurrentLocation resets all changes to the "current_location" field.
func (m *VehicleMutation) ResetCurrentLocation() {
	m.current_location = nil
	delete(m.clearedFields, vehicle.FieldCurrentLocation)
}

// SetExt sets the "ext" field.
func (m *VehicleMutation) SetExt(value *map[string]interface{}) {
	m.ext = &value
}

// Ext returns the value of the "ext" field in the mutation.
func (m *VehicleMutation) Ext() (r *map[string]interface{}, exists bool) {
	v := m.ext
	if v == nil {
		return
	}
	return *v, true
}

// OldExt returns the old "ext" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldExt(ctx context.Context) (v *map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExt: %w", err)
	}
	return oldValue.Ext, nil
}

// ClearExt clears the value of the "ext" field.
func (m *VehicleMutation) ClearExt() {
	m.ext = nil
	m.clearedFields[vehicle.FieldExt] = struct{}{}
}

// ExtCleared returns if the "ext" field was cleared in this mutation.
func (m *VehicleMutation) ExtCleared() bool {
	_, ok := m.clearedFields[vehicle.FieldExt]
	return ok
}

// ResetExt resets all changes to the "ext" field.
func (m *VehicleMutation) ResetExt() {
	m.ext = nil
	delete(m.clearedFields, vehicle.FieldExt)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VehicleMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VehicleMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VehicleMutation) UserCleared() bool {
	return m.OwnerIDCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VehicleMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VehicleMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VehicleMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddRideIDs adds the "rides" edge to the Ride entity by ids.
func (m *VehicleMutation) AddRideIDs(ids ...uuid.UUID) {
	if m.rides == nil {
		m.rides = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.rides[ids[i]] = struct{}{}
	}
}

// ClearRides clears the "rides" edge to the Ride entity.
func (m *VehicleMutation) ClearRides() {
	m.clearedrides = true
}

// RidesCleared reports if the "rides" edge to the Ride entity was cleared.
func (m *VehicleMutation) RidesCleared() bool {
	return m.clearedrides
}

// RemoveRideIDs removes the "rides" edge to the Ride entity by IDs.
func (m *VehicleMutation) RemoveRideIDs(ids ...uuid.UUID) {
	if m.removedrides == nil {
		m.removedrides = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.rides, ids[i])
		m.removedrides[ids[i]] = struct{}{}
	}
}

// RemovedRides returns the removed IDs of the "rides" edge to the Ride entity.
func (m *VehicleMutation) RemovedRidesIDs() (ids []uuid.UUID) {
	for id := range m.removedrides {
		ids = append(ids, id)
	}
	return
}

// RidesIDs returns the "rides" edge IDs in the mutation.
func (m *VehicleMutation) RidesIDs() (ids []uuid.UUID) {
	for id := range m.rides {
		ids = append(ids, id)
	}
	return
}

// ResetRides resets all changes to the "rides" edge.
func (m *VehicleMutation) ResetRides() {
	m.rides = nil
	m.clearedrides = false
	m.removedrides = nil
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vehicle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.city != nil {
		fields = append(fields, vehicle.FieldCity)
	}
	if m._type != nil {
		fields = append(fields, vehicle.FieldType)
	}
	if m.user != nil {
		fields = append(fields, vehicle.FieldOwnerID)
	}
	if m.creation_time != nil {
		fields = append(fields, vehicle.FieldCreationTime)
	}
	if m.status != nil {
		fields = append(fields, vehicle.FieldStatus)
	}
	if m.current_location != nil {
		fields = append(fields, vehicle.FieldCurrentLocation)
	}
	if m.ext != nil {
		fields = append(fields, vehicle.FieldExt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCity:
		return m.City()
	case vehicle.FieldType:
		return m.GetType()
	case vehicle.FieldOwnerID:
		return m.OwnerID()
	case vehicle.FieldCreationTime:
		return m.CreationTime()
	case vehicle.FieldStatus:
		return m.Status()
	case vehicle.FieldCurrentLocation:
		return m.CurrentLocation()
	case vehicle.FieldExt:
		return m.Ext()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldCity:
		return m.OldCity(ctx)
	case vehicle.FieldType:
		return m.OldType(ctx)
	case vehicle.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case vehicle.FieldCreationTime:
		return m.OldCreationTime(ctx)
	case vehicle.FieldStatus:
		return m.OldStatus(ctx)
	case vehicle.FieldCurrentLocation:
		return m.OldCurrentLocation(ctx)
	case vehicle.FieldExt:
		return m.OldExt(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case vehicle.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case vehicle.FieldOwnerID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case vehicle.FieldCreationTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreationTime(v)
		return nil
	case vehicle.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case vehicle.FieldCurrentLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentLocation(v)
		return nil
	case vehicle.FieldExt:
		v, ok := value.(*map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExt(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehicle.FieldType) {
		fields = append(fields, vehicle.FieldType)
	}
	if m.FieldCleared(vehicle.FieldOwnerID) {
		fields = append(fields, vehicle.FieldOwnerID)
	}
	if m.FieldCleared(vehicle.FieldCreationTime) {
		fields = append(fields, vehicle.FieldCreationTime)
	}
	if m.FieldCleared(vehicle.FieldStatus) {
		fields = append(fields, vehicle.FieldStatus)
	}
	if m.FieldCleared(vehicle.FieldCurrentLocation) {
		fields = append(fields, vehicle.FieldCurrentLocation)
	}
	if m.FieldCleared(vehicle.FieldExt) {
		fields = append(fields, vehicle.FieldExt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	switch name {
	case vehicle.FieldType:
		m.ClearType()
		return nil
	case vehicle.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case vehicle.FieldCreationTime:
		m.ClearCreationTime()
		return nil
	case vehicle.FieldStatus:
		m.ClearStatus()
		return nil
	case vehicle.FieldCurrentLocation:
		m.ClearCurrentLocation()
		return nil
	case vehicle.FieldExt:
		m.ClearExt()
		return nil
	}
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldCity:
		m.ResetCity()
		return nil
	case vehicle.FieldType:
		m.ResetType()
		return nil
	case vehicle.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case vehicle.FieldCreationTime:
		m.ResetCreationTime()
		return nil
	case vehicle.FieldStatus:
		m.ResetStatus()
		return nil
	case vehicle.FieldCurrentLocation:
		m.ResetCurrentLocation()
		return nil
	case vehicle.FieldExt:
		m.ResetExt()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, vehicle.EdgeUser)
	}
	if m.rides != nil {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case vehicle.EdgeRides:
		ids := make([]ent.Value, 0, len(m.rides))
		for id := range m.rides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrides != nil {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vehicle.EdgeRides:
		ids := make([]ent.Value, 0, len(m.removedrides))
		for id := range m.removedrides {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, vehicle.EdgeUser)
	}
	if m.clearedrides {
		edges = append(edges, vehicle.EdgeRides)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	switch name {
	case vehicle.EdgeUser:
		return m.cleareduser
	case vehicle.EdgeRides:
		return m.clearedrides
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	switch name {
	case vehicle.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	switch name {
	case vehicle.EdgeUser:
		m.ResetUser()
		return nil
	case vehicle.EdgeRides:
		m.ResetRides()
		return nil
	}
	return fmt.Errorf("unknown Vehicle edge %s", name)
}

// VehicleLocationHistoryMutation represents an operation that mutates the VehicleLocationHistory nodes in the graph.
type VehicleLocationHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	city          *string
	timestamp     *time.Time
	lat           *float64
	addlat        *float64
	long          *float64
	addlong       *float64
	clearedFields map[string]struct{}
	rides         *uuid.UUID
	clearedrides  bool
	done          bool
	oldValue      func(context.Context) (*VehicleLocationHistory, error)
	predicates    []predicate.VehicleLocationHistory
}

var _ ent.Mutation = (*VehicleLocationHistoryMutation)(nil)

// vehiclelocationhistoryOption allows management of the mutation configuration using functional options.
type vehiclelocationhistoryOption func(*VehicleLocationHistoryMutation)

// newVehicleLocationHistoryMutation creates new mutation for the VehicleLocationHistory entity.
func newVehicleLocationHistoryMutation(c config, op Op, opts ...vehiclelocationhistoryOption) *VehicleLocationHistoryMutation {
	m := &VehicleLocationHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleLocationHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleLocationHistoryID sets the ID field of the mutation.
func withVehicleLocationHistoryID(id uuid.UUID) vehiclelocationhistoryOption {
	return func(m *VehicleLocationHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleLocationHistory
		)
		m.oldValue = func(ctx context.Context) (*VehicleLocationHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleLocationHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleLocationHistory sets the old VehicleLocationHistory of the mutation.
func withVehicleLocationHistory(node *VehicleLocationHistory) vehiclelocationhistoryOption {
	return func(m *VehicleLocationHistoryMutation) {
		m.oldValue = func(context.Context) (*VehicleLocationHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleLocationHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleLocationHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VehicleLocationHistory entities.
func (m *VehicleLocationHistoryMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleLocationHistoryMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleLocationHistoryMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VehicleLocationHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *VehicleLocationHistoryMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *VehicleLocationHistoryMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the VehicleLocationHistory entity.
// If the VehicleLocationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleLocationHistoryMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *VehicleLocationHistoryMutation) ResetCity() {
	m.city = nil
}

// SetRideID sets the "ride_id" field.
func (m *VehicleLocationHistoryMutation) SetRideID(u uuid.UUID) {
	m.rides = &u
}

// RideID returns the value of the "ride_id" field in the mutation.
func (m *VehicleLocationHistoryMutation) RideID() (r uuid.UUID, exists bool) {
	v := m.rides
	if v == nil {
		return
	}
	return *v, true
}

// OldRideID returns the old "ride_id" field's value of the VehicleLocationHistory entity.
// If the VehicleLocationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleLocationHistoryMutation) OldRideID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRideID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRideID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRideID: %w", err)
	}
	return oldValue.RideID, nil
}

// ResetRideID resets all changes to the "ride_id" field.
func (m *VehicleLocationHistoryMutation) ResetRideID() {
	m.rides = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *VehicleLocationHistoryMutation) SetTimestamp(t time.Time) {
	m.timestamp = &t
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *VehicleLocationHistoryMutation) Timestamp() (r time.Time, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the VehicleLocationHistory entity.
// If the VehicleLocationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleLocationHistoryMutation) OldTimestamp(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *VehicleLocationHistoryMutation) ResetTimestamp() {
	m.timestamp = nil
}

// SetLat sets the "lat" field.
func (m *VehicleLocationHistoryMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *VehicleLocationHistoryMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the VehicleLocationHistory entity.
// If the VehicleLocationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleLocationHistoryMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *VehicleLocationHistoryMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *VehicleLocationHistoryMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *VehicleLocationHistoryMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[vehiclelocationhistory.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *VehicleLocationHistoryMutation) LatCleared() bool {
	_, ok := m.clearedFields[vehiclelocationhistory.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *VehicleLocationHistoryMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, vehiclelocationhistory.FieldLat)
}

// SetLong sets the "long" field.
func (m *VehicleLocationHistoryMutation) SetLong(f float64) {
	m.long = &f
	m.addlong = nil
}

// Long returns the value of the "long" field in the mutation.
func (m *VehicleLocationHistoryMutation) Long() (r float64, exists bool) {
	v := m.long
	if v == nil {
		return
	}
	return *v, true
}

// OldLong returns the old "long" field's value of the VehicleLocationHistory entity.
// If the VehicleLocationHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleLocationHistoryMutation) OldLong(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLong: %w", err)
	}
	return oldValue.Long, nil
}

// AddLong adds f to the "long" field.
func (m *VehicleLocationHistoryMutation) AddLong(f float64) {
	if m.addlong != nil {
		*m.addlong += f
	} else {
		m.addlong = &f
	}
}

// AddedLong returns the value that was added to the "long" field in this mutation.
func (m *VehicleLocationHistoryMutation) AddedLong() (r float64, exists bool) {
	v := m.addlong
	if v == nil {
		return
	}
	return *v, true
}

// ClearLong clears the value of the "long" field.
func (m *VehicleLocationHistoryMutation) ClearLong() {
	m.long = nil
	m.addlong = nil
	m.clearedFields[vehiclelocationhistory.FieldLong] = struct{}{}
}

// LongCleared returns if the "long" field was cleared in this mutation.
func (m *VehicleLocationHistoryMutation) LongCleared() bool {
	_, ok := m.clearedFields[vehiclelocationhistory.FieldLong]
	return ok
}

// ResetLong resets all changes to the "long" field.
func (m *VehicleLocationHistoryMutation) ResetLong() {
	m.long = nil
	m.addlong = nil
	delete(m.clearedFields, vehiclelocationhistory.FieldLong)
}

// SetRidesID sets the "rides" edge to the Ride entity by id.
func (m *VehicleLocationHistoryMutation) SetRidesID(id uuid.UUID) {
	m.rides = &id
}

// ClearRides clears the "rides" edge to the Ride entity.
func (m *VehicleLocationHistoryMutation) ClearRides() {
	m.clearedrides = true
}

// RidesCleared reports if the "rides" edge to the Ride entity was cleared.
func (m *VehicleLocationHistoryMutation) RidesCleared() bool {
	return m.clearedrides
}

// RidesID returns the "rides" edge ID in the mutation.
func (m *VehicleLocationHistoryMutation) RidesID() (id uuid.UUID, exists bool) {
	if m.rides != nil {
		return *m.rides, true
	}
	return
}

// RidesIDs returns the "rides" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RidesID instead. It exists only for internal usage by the builders.
func (m *VehicleLocationHistoryMutation) RidesIDs() (ids []uuid.UUID) {
	if id := m.rides; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRides resets all changes to the "rides" edge.
func (m *VehicleLocationHistoryMutation) ResetRides() {
	m.rides = nil
	m.clearedrides = false
}

// Where appends a list predicates to the VehicleLocationHistoryMutation builder.
func (m *VehicleLocationHistoryMutation) Where(ps ...predicate.VehicleLocationHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleLocationHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleLocationHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VehicleLocationHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleLocationHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleLocationHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VehicleLocationHistory).
func (m *VehicleLocationHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleLocationHistoryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.city != nil {
		fields = append(fields, vehiclelocationhistory.FieldCity)
	}
	if m.rides != nil {
		fields = append(fields, vehiclelocationhistory.FieldRideID)
	}
	if m.timestamp != nil {
		fields = append(fields, vehiclelocationhistory.FieldTimestamp)
	}
	if m.lat != nil {
		fields = append(fields, vehiclelocationhistory.FieldLat)
	}
	if m.long != nil {
		fields = append(fields, vehiclelocationhistory.FieldLong)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleLocationHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehiclelocationhistory.FieldCity:
		return m.City()
	case vehiclelocationhistory.FieldRideID:
		return m.RideID()
	case vehiclelocationhistory.FieldTimestamp:
		return m.Timestamp()
	case vehiclelocationhistory.FieldLat:
		return m.Lat()
	case vehiclelocationhistory.FieldLong:
		return m.Long()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleLocationHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehiclelocationhistory.FieldCity:
		return m.OldCity(ctx)
	case vehiclelocationhistory.FieldRideID:
		return m.OldRideID(ctx)
	case vehiclelocationhistory.FieldTimestamp:
		return m.OldTimestamp(ctx)
	case vehiclelocationhistory.FieldLat:
		return m.OldLat(ctx)
	case vehiclelocationhistory.FieldLong:
		return m.OldLong(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleLocationHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleLocationHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehiclelocationhistory.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case vehiclelocationhistory.FieldRideID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRideID(v)
		return nil
	case vehiclelocationhistory.FieldTimestamp:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	case vehiclelocationhistory.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case vehiclelocationhistory.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLong(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleLocationHistoryMutation) AddedFields() []string {
	var fields []string
	if m.addlat != nil {
		fields = append(fields, vehiclelocationhistory.FieldLat)
	}
	if m.addlong != nil {
		fields = append(fields, vehiclelocationhistory.FieldLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleLocationHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehiclelocationhistory.FieldLat:
		return m.AddedLat()
	case vehiclelocationhistory.FieldLong:
		return m.AddedLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleLocationHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehiclelocationhistory.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case vehiclelocationhistory.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLong(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleLocationHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vehiclelocationhistory.FieldLat) {
		fields = append(fields, vehiclelocationhistory.FieldLat)
	}
	if m.FieldCleared(vehiclelocationhistory.FieldLong) {
		fields = append(fields, vehiclelocationhistory.FieldLong)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleLocationHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleLocationHistoryMutation) ClearField(name string) error {
	switch name {
	case vehiclelocationhistory.FieldLat:
		m.ClearLat()
		return nil
	case vehiclelocationhistory.FieldLong:
		m.ClearLong()
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleLocationHistoryMutation) ResetField(name string) error {
	switch name {
	case vehiclelocationhistory.FieldCity:
		m.ResetCity()
		return nil
	case vehiclelocationhistory.FieldRideID:
		m.ResetRideID()
		return nil
	case vehiclelocationhistory.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	case vehiclelocationhistory.FieldLat:
		m.ResetLat()
		return nil
	case vehiclelocationhistory.FieldLong:
		m.ResetLong()
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleLocationHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rides != nil {
		edges = append(edges, vehiclelocationhistory.EdgeRides)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleLocationHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehiclelocationhistory.EdgeRides:
		if id := m.rides; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleLocationHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleLocationHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleLocationHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrides {
		edges = append(edges, vehiclelocationhistory.EdgeRides)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleLocationHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case vehiclelocationhistory.EdgeRides:
		return m.clearedrides
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleLocationHistoryMutation) ClearEdge(name string) error {
	switch name {
	case vehiclelocationhistory.EdgeRides:
		m.ClearRides()
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleLocationHistoryMutation) ResetEdge(name string) error {
	switch name {
	case vehiclelocationhistory.EdgeRides:
		m.ResetRides()
		return nil
	}
	return fmt.Errorf("unknown VehicleLocationHistory edge %s", name)
}
